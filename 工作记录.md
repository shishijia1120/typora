# 工作记录

## 第一周

### 1 环境配置

- minio

  

- Git

  - 配置用户名和邮箱

  - SSH密钥

    https://www.cnblogs.com/supergg1990/p/6844952.html

    - 生成密钥对

      ```bash
      $ cd ~/.ssh
      $ ls
      ```

  ![image-20210406161810973](C:\Users\blackwalnut555\AppData\Roaming\Typora\typora-user-images\image-20210406161810973.png)

- Git可视化工具：gitkraken or sourcetree
- Python

  - 下载：3.7
  - 环境变量配置：
- VS Code
  - 扩展安装：
    - Python Docstring Generator:Automatically generates detailed docstrings for python functions
  - python
    - ESlint
    - autopep8

### 2 工作安排

#### 工作安排1.0

- 从minio上获取用户上传的格式为.zip的压缩包

- 解压缩为文件夹，备份文件夹

- 对文件实体进行重命名，防止出现重名文件，得到重命名的新文件夹

  - 将新文件夹上传到minio

  - 设置图片url可永久访问

    1. 配置bucket策略，默认情况下，minio没有配置匿名读写的权限，新增Read权限(Read and Write均可)，可通过链接的方式直接访问该文件。

    2. 上传文件时，设置header为application/octet-stream时，浏览器打开链接会默认进行下载而不是在浏览器中加载文件，所以如果想要文件时直接打开，上传时则不要设置application/octet-stream。jpg图片的话，可设置为image/jpeg。

    - 设置Bucket的访问策略：https://github.com/minio/minio-py/blob/master/examples/set_bucket_policy.py

    - minio如何设置直接通过访问链接在浏览器中打开文件：https://www.tqwba.com/x_d/jishu/57243.html

    - 设置图片url可永久访问：https://blog.csdn.net/weixin_31360095/article/details/113708258

      ​										https://blog.csdn.net/instanceof_zjl/article/details/109601131?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1329188.8925.16178499636706121&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control

      下载MinIO客户端
      以windows为例
      下载下来有一个mc.exe程序
      打开cmd窗口

      执行
      mc config host add minio http://127.0.0.1:9000 minioadmin minioadmin --api S3v4
      mc policy set public minio/bucket (bucket修改成你自己的名字)

    - 获取url：https://docs.min.io/docs/python-client-api-reference#presigned_get_object

    

- 得到新文件夹的json数据


```json
[
    {
        'label': '标签名 1',
        'labelID': 'sijezlndijfdvxki',
        'count': '对应标签数量 1',
        'files': [
            {
                'url': '对应 minio 的 url',
                'path': '对应存储的路径'
            },
            {
                'url': '对应 minio 的 url',
                'path': '对应存储的路径'
            }
        ]
    },
    {
        'label': '标签名 2',
        'labelID': 'balebvkciadketjf',
        'count': '对应标签数量 2',
        'files': [
            {
                'url': '对应 minio 的 url',
                'path': '对应存储的路径'
            },
            {
                'url': '对应 minio 的 url',
                'path': '对应存储的路径'
            }
        ]
    }
]
```

- 支持在线修改标签



#### 工作安排2.0

- 本地项目名：AutoML

- 主运行文件：app.py
- 存放数据文件夹：data
  - 项目文件夹：ProjectIDxxxxx
    - origin：zip包A(从minio上获取的压缩包)、原始文件夹A1(解压缩后)
    - view：去除A2中的子文件分类，把所有图片直接放在view文件夹下
    - working：备份后重命名文件夹(需删除非图片文件)
    - training：。。。





#### 工作安排3.0

项目目录：AutoML

- 功能1：从minio下载zip压缩包：
- 功能2：解压缩+备份、重命名、删除非图片文件=>得到B文件夹：
- 功能3：得到去除子文件夹的最终文件夹view，将view上传到minio上
- 功能4：将B形成json数据集
- 功能5：开发定时轮询获取数据集功能
- 功能6：开发Python Flask蓝图接受请求功能



#### 第二周准备

- python form-data file

  https://www.cnblogs.com/SunshineKimi/p/11957525.html

- http

- flask blueprint

- http://ubibots.zucc.edu.cn/BlackWalnutLabsAICloud/NoahAIExplorer/automldoc/-/blob/master/protocol/uploadDatasetAnalysisResults.md







明天记得看一下：https://www.xiaoheidiannao.com/14083.html

### 3 minio

#### 3.1 MinIO Python SDK for Amazon S3 Compatible Cloud Storage

>  [Minio Cookbook 中文版](https://www.bookstack.cn/books/MinioCookbookZH)：https://www.bookstack.cn/read/MinioCookbookZH/23.md
>
>  minio github：https://github.com/minio/minio

- Download using pip

  ```bash
  pip3 install minio
  ```

- Download source

  ```bash
  git clone https://github.com/minio/minio-py
  cd minio-py
  python setup.py install
  ```

- 启动minio
  启动一个cmd窗口，进入mino.exe所在文件夹(C:\Users\blackwalnut555\Downloads)，输入如下命令：

  ```bash
  minio.exe server  D:\environments\minioserver
  ```

   后面是你图片上传之后的存储目录。

  运行成功之后，会看到下面的界面，这里minio会给出ACCESS-KEY 和 SECRET-KEY，供后台管理登录使用。

- 创建桶和上传图片

  在后台管理界面你可以上创建你的Bucket(桶)，可以理解为一个文件夹用来存放图片。桶创建成功之后就可以上传图片了。在文件列表的右边可以复制出图片的访问地址，在浏览器中就可以访问图片了。这个时候的图片地址是带过期时间和密钥的。

  

- Quick Start Example---File Uploader

  this example program connects to an S3-compatible object storage, make a bucket on that server, and upload a file to the bucket.

  - you need the following MinIO server playground [https://play.min.io](https://play.min.io/). Feel free to use this service for test and development.

  | Parameters | Description                                                |
  | ---------- | ---------------------------------------------------------- |
  | Endpoint   | URL to S3 service.                                         |
  | Access Key | Access key (aka user ID) of an account in the S3 service.  |
  | Secret Key | Secret key (aka password) of an account in the S3 service. |



file_uploader.py

```python
from minio import Minio
from minio.error import S3Error


def main():
    # Create a client with the MinIO server playground, its access key
    # and secret key.
    client = Minio(
        "play.min.io",
        access_key="Q3AM3UQ867SPQQA43P2F",
        secret_key="zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG",
    )

    # Make 'asiatrip' bucket if not exist.
    found = client.bucket_exists("asiatrip")
    if not found:
        client.make_bucket("asiatrip")
    else:
        print("Bucket 'asiatrip' already exists")

    # Upload '/home/user/Photos/asiaphotos.zip' as object name
    # 'asiaphotos-2015.zip' to bucket 'asiatrip'.
    client.fput_object(
        "asiatrip", "asiaphotos-2015.zip", "/home/user/Photos/asiaphotos.zip",
    )
    print(
        "'/home/user/Photos/asiaphotos.zip' is successfully uploaded as "
        "object 'asiaphotos-2015.zip' to bucket 'asiatrip'."
    )


if __name__ == "__main__":
    try:
        main()
    except S3Error as exc:
        print("error occurred.", exc)
```

Run File Uploader

```bash
$ python file_uploader.py
'/home/user/Photos/asiaphotos.zip' is successfully uploaded as object 'asiaphotos-2015.zip' to bucket 'asiatrip'.

$ mc ls play/asiatrip/
[2016-06-02 18:10:29 PDT]  82KiB asiaphotos-2015.zip
```





#### 3.2 Constructor



```python
from minio import Minio

client = Minio(
    "play.minio.io:9000",
    access_key="Q3AM3UQ867SPQQA43P2F",
    secret_key="zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG",
    region="my-region",
)
```









#### 3.3 Bucket operations













#### 3.4 Object operations

- get_object

  https://docs.min.io/docs/python-client-api-reference.html#get_object

  ```python
  
  
  
  
  
  ```




#### 3.5 minio客户端mc

下载：

进入mc.exe目录下，在mc存放目录下执行，

- 将mc连接到minio服务器：

  ```bash
  mc config host add minio http://ip:9000 minio服务器用户名 minio服务器密码 --api S3V4
  ```

  成功的信息提示：

  ```bash
  Added `minio` successfully.
  ```

- 设置永久访问桶:

  ```bash
  mc policy set public minio/bucket
  ```

  成功的提示：

  ```bash
  Access permission for `minio/桶名` is set to `public`
  ```

- 设置minioclient api生成的链接能永久访问

  ```python
  String url = client.presignedGetObject(bucketName, objectName, expires);
  ```

  虽然我们把桶设置了public，但此时通过api生成的访问链接还是有过期时间的，取决于expires的设置，最大7天

  需要把api生成的链接进行改造：

  把生成的链接通过`?`切割，得到前面的部分，就是可访问的永久链接。

  ```bash
  url.split('?')[0]
  ```

  



#### Python3之minio读取

- 读取bucket下面的xx.txt文件，返回str

    ```python
    import minio

    MINIO_CONF = {
            'endpoint': '127.0.0.1:9000',
            'access_key': 'name',
            'secret_key': 'pwd',
            'secure': False
        }

    def latest_minio_find(bucket: str):
        client = minio.Minio(**MINIO_CONF)
        if not client.bucket_exists(bucket):
            return None
        data = client.get_object(bucket, 'xx.txt')
        return data.data.decode('utf-8')
    ```
    
    ```python
        from minio import Minio
        minioClient = Minio('0.0.0.0:9000',access_key='xxxx',secret_key='xxx',secure=False)
        '''
        服务为HTTP时secure使用False，服务为HTTPs时secure使用Ture。
        否则会报urllib3.exceptions.MaxRetryError: 
        HTTPSConnectionPool(host='192.8.21.87', port=9000): 
        Max retries exceeded with url:
         /new/ (Caused by SSLError(SSLEOFError(8, 'EOF occurred in violation of protocol (_ssl.c:833)'),))的错误
        '''

        minioClient.make_bucket("mybucket")#生成一个bucket，类似文件夹
    ```

​	

- 上传文件

  ```python
  	# 上传zip文件
      client.fput_object(bucket_name=bucket, object_name=file_name,
                         file_path=file_path,
                         content_type='application/zip'
                         )
  ```

  

- 改写文件内容

  ```python
  		date_str ='202001011000'
          stream = io.BytesIO(date_str)
          client.put_object(bucket_name=bucket,
                            object_name="xx.txt",
                            data=stream, length=len(date_str),
                            content_type='text/plain')
  ```



### 4 Python

> Python API文档：https://docs.python.org/

#### 4.1 files

- open()方法

  - Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。
  - 参数：常用参数(file、mode)
    - file:文件路径(相对或绝对路径)
    - mode:可选，文件打开模式
      - r
      - w:打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
      - wb:以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。

- file对象

  file对象使用open函数来创建：




#### 4.2  OS

- os.listdir()

  - os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。这个列表以字母顺序。 它不包括 '.' 和'..' 即使它在文件夹中。
  - 参数:
    - path--需要列出的目录路径
  - 返回值：返回指定路径下的文件和文件夹列表

##### 4.2.1 os.path()模块

> https://www.runoob.com/python3/python3-os-path.html

- os.path.join()

  -  将目录和文件名合成一个路径

    ```python
    print( os.path.join('root','test','runoob.txt') )  # 将目录和文件名合成一个路径
    ```
  
- os.path.isdir()
  
  - 判断路径是否为目录
  
    

##### 4.2.2 os.walk()







### 5 Python中的zipfile模块

#### 5.1 压缩文件的基本信息

- 导入模块

  ```bash
  import zipfile
  ```

  

- zipfile.ZipFile()

  - 参数:

    - file
    - mode
    - 

    ```python
    file_dir = './test.zip'
    zipFile = zipfile.ZipFile(file_dir)
    ```

    

- zipFile.infolist()

  ```python
  print(zipFile.infolist())
  ```

  - 获取zip文档内所有文件的信息，返回一个zipfile.ZipInfo的列表

  ```bash
  [<ZipInfo filename='test/' external_attr=0x10>, <ZipInfo filename='test/1576040444218.jpg' compress_type=deflate external_attr=0x20 file_size=370203 compress_size=369999>, <ZipInfo filename='test/1576040449795.jpg' compress_type=deflate external_attr=0x20 file_size=322181 compress_size=321626>, <ZipInfo filename='test/1576040451192.jpg' compress_type=deflate external_attr=0x20 file_size=352416 compress_size=350824>]
  ```

- zipFile.namelist()

  - 获取zip文档内所有文件的名称列表

    ```bash
    ['test/', 'test/1576040444218.jpg', 'test/1576040449795.jpg', 'test/1576040451192.jpg']
    ```

- zipFile.printdir()

  - 将zip文档内的信息打印到控制台上

    ```python
    print(zipFile.printdir())
    ```

#### 5.2 解压文件

- zipFile.extract()



### 6 具体工作

https://blog.csdn.net/LeonTom/article/details/101509677

#### 6.1 从minio下载压缩包

```python
def load_data_minio(bucket: str):
    client = minio.Minio(**minio_conf)
    if not client.bucket_exists(bucket):
        return None
    data = client.fget_object(bucket, 'TrafficSign-Dirty.zip','./download/receive.zip')

print(load_data_minio("atest"))
```





#### 6.2 Python解压缩zip文件（zipfile）

```python
def unzip_data_minio() :
    file_dir =  './download/receive.zip' 
    zipFile = zipfile.ZipFile(file_dir)
    zipFile.extractall('./download/unzip_data/') 
    zipFile.close()
```







#### 6.3 文件备份、筛选、重命名

##### uuid4

> https://blog.csdn.net/catwan/article/details/84998986

- uud.uuid1()

- uud.uuid3()

- uud.uuid4():基于随机数，通过随机数来生成UUID. 使用的是伪随机数有一定的重复概率. 

  

  ```python
  def rename_file(path):
      subfolderList=[]
      filelist = os.listdir(path)
      for file in filelist:
          Olddir = os.path.join(path,file)
          if os.path.isdir(Olddir):
              subfolderList.append(file)
              continue
          
          filename = os.path.splitext(file)[0]
          filetype = os.path.splitext(file)[1]
          if filetype == '.jpg':
              Newdir = os.path.join(path,str(uuid.uuid4().hex)+filetype)
              os.rename(Olddir,Newdir)
      for subfolder in subfolderList:
          rename_file(path+subfolder)
          print('子文件夹'+subfolder+'重命名完毕!')    
      
  
  def rename():
      path = "./download/unzip_data"
      path_copy = './download/unzip_data_copy/'
      shutil.copytree(path,path_copy)
      print("文件夹备份完毕!")
      rename_file(path_copy)
  rename()
  ```

  修改后重命名+上传的版本：
  
  ```python
  def rename_file(path):
      subfolderList=[]
      filelist = os.listdir(path)
      for file in filelist:
          Olddir = os.path.join(path,file)
          if os.path.isdir(Olddir):
              subfolderList.append(file)
              continue
          
          filename = os.path.splitext(file)[0]
          filetype = os.path.splitext(file)[1]
          if filetype == '.jpg':
              Newdir = os.path.join(path,str(uuid.uuid4().hex)+filetype)
              # print(Newdir.replace('\\','/'))
              os.rename(Olddir,Newdir)
              address = Newdir.replace('\\','/')
              upload_data_minio('atest',address,address)        
      for subfolder in subfolderList:
          rename_file(path+'/'+subfolder)
          print('子文件夹'+subfolder+'重命名完毕!')    
     
      
  def rename():
      path = "download/unzip_data"
      path_copy = 'download/unzip_data_copy' 
      shutil.copytree(path,path_copy)
      print("文件夹备份完毕!")
      rename_file(path_copy)
  ```
  
  删除文件：https://www.cnblogs.com/xxpythonxx/p/12577414.html



#### 6.4 得到minio文件中的json数据

##### 配置minio图片永久访问

> https://blog.csdn.net/weixin_31360095/article/details/113708258
>
> https://blog.csdn.net/instanceof_zjl/article/details/109601131?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1329188.8925.16178499636706121&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control

###### 1. 通过客户端mc设置

- https://blog.csdn.net/instanceof_zjl/article/details/109601131?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1329188.8925.16178499636706121&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control



###### 2. 通过set_bucket_policy设置

```python
# Example anonymous read-write bucket policy.
policy = {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {"AWS": "*"},
            "Action": [
                "s3:GetBucketLocation",
                "s3:ListBucket",
                "s3:ListBucketMultipartUploads",
            ],
            "Resource": "arn:aws:s3:::atest",
        },
        {
            "Effect": "Allow",
            "Principal": {"AWS": "*"},
            "Action": [
                "s3:GetObject",
                "s3:PutObject",
                "s3:DeleteObject",
                "s3:ListMultipartUploadParts",
                "s3:AbortMultipartUpload",
            ],
            "Resource": "arn:aws:s3:::atest/*",
        },
    ],
}

client = minio.Minio(**minio_conf)

client.set_bucket_policy("atest", json.dumps(policy))
```







#### 6.5 开发定时轮询获取数据集功能

> https://www.cnblogs.com/kaerxifa/p/11481047.html
>
> https://blog.csdn.net/u011561613/article/details/100516768



```python
from threading import Timer
import urllib.request
import requests


def get_web():
    url='http://www.baidu.com'
    res = requests.get(url)
    print(res.status_code)

def get_website():
    url='http://www.baidu.com'
    req = urllib.request.Request(url)
    resp = urllib.request.urlopen(req)
    result = resp.read().decode('utf-8')
    print(result)
  
class LoopTimer(Timer):
    
    
    def __init__(self,interval,function,args=[],kwargs={}):
        Timer.__init__(self,interval,function,args,kwargs)
    
    def run(self):
        while True:
            self.finished.wait(self.interval)
            if self.finished.is_set():
                self.finished.set()
                break
            self.function(*self.args,**self.kwargs)
            

t = LoopTimer(3.0,get_website)
t.start()
```

##### 1. threading.Timer





##### 2. requests



##### 3. urllib.request









#### 6.6  开发Python Flask蓝图接受请求功能









#### 6.7 编写测试用例







### 7 测试

> https://www.cnblogs.com/miki-peng/p/12501341.html

#### unittest

unittest最核心的四个部分是：

- TestCase
  - 用户自定义的测试case的基类，调用run()方法，会依次调用setUp方法、执行用例的方法、tearDown方法。
- TestSuite
  - 测试用例集合，可以通过addTest()方法手动增加Test Case，也可以通过TestLoader自动添加Test Case，TestLoader在添加用例时，会没有顺序。
- TestRunner
  - 运行测试用例的驱动类，可以执行TestCase，也可以执行TestSuite，执行后TestCase和TestSuite会自动管理TESTResult。
- TestFixture
  - 简单来说就是做一些测试过程中需要准备的东西，比如创建临时的数据库，文件和目录等，其中setUp()和setDown()是最常用的方法

##### unittest的断言

| **方法**                   | **检查**            |
| :------------------------- | :------------------ |
| assertEqual(a, b,msg=None) | a ==b               |
| assertNotEqual(a, b)       | a !=b               |
| assertTrue(x)              | bool(x) is True     |
| assertFalse(x)             | Bool(x) is False    |
| assertIs(a, b)             | a is b              |
| assertIsNot(a, b)          | a is not b          |
| assertIsNone(x)            | x is None           |
| assertIsNotNone(x)         | x is not None       |
| assertIn(a, b)             | a in b              |
| assertNotIn(a, b)          | a not in b          |
| assertIsInstance(a, b)     | isinstance(a,b)     |
| assertNotIsInstance(a, b)  | not isinstance(a,b) |

 如果断言失败即不通过就会抛出一个`AssertionError`断言错误，成功则标识为通过，以上几种方式都有一个共同点，就是都有一个msg参数（表中只列了一个，其实都有），默认是None，即`msg = None`，如果指定msg参数的值，则将该信息作为失败的错误信息返回。





##### TestCase测试用例

编写测试用例前，我们需要建一个测试类继承unittest里面的TestCase类，继承这个类之后我们才是真正的使用unittest框架去写测试用例，编写测试用例的步骤如下：

- 导入unittest模块
- 创建一个测试类，并继承unittest.TestCase()
- 定义测试方法，方法名必须以test_开头
- 调用unittest.main()方法来运行测试用例，unittest.main()方法会搜索该模块下所有以test开头的测试用例方法，并自动执行





##### TestFixure测试夹具

unittest的测试夹具有两种使用方式，一种是以测试方法为维度的`setUp()`和`tearDown()`，一种是以测试类为维度的`setUpClass()`和`tearDownClass()`。









##### TestSuite测试套件

unittest.TestSuite()类来表示一个测试用例集，把需要执行的用例类或模块存到一起，常用的方法如下：

- unittest.TestSuite()

  - addTest()：添加单个测试用例方法
  - addTests([]):添加多个测试用例方法，方法名存在一个列表

- unittest.TestLoader()

  - loadTestFromTestCase(测试类名)：添加一个测试类
  - loadTestFromModule(模块名)：添加一个模块
  - discover(测试用例的所在目录)：指定目录去加载，会自动寻找这个目录下所有符合命名规则的测试用例

  ```python
  import unittest
  import test_register
  
  # 第一步，创建一个测试套件
  suite = unittest.TestSuite()
  
  # 第二步：将测试用例，加载到测试套件中
  
  # 方式1：添加单条测试用例
  # 创建一个用例对象，注意：通过用例类去创建测试用例对象
  # case = test_register.TestRegister("test_register_success")
  
  
  # 方式2：添加多条测试用例
  # case1 = test_register.TestRegister("test_register_success")
  # case2 = test_register.TestRegister("test_username_isnull")
  # suite.addTest([case1, case2])	# 添加用例到测试套件中 //???应该是addTests吧
  
  # 方式3：添加一个测试用例类
  # loader = unittest.TestLoader() #创建一个加载对象
  # suite.addTest(loader.loadTestsFromTestCase(test_register.TestRegister))
  
  # 方式4：添加一个模块
  # 方式4，添加一个模块
  loader = unittest.TestLoader()	# 创建一个加载对象
  suite.addTest(loader.loadTestsFromModule(test_register))
  
  
  # 方式5，指定测试用例的所在的目录路径，进行加载
  # loader = unittest.TestLoader()
  # suite.addTest(loader.discover(r"d:\learn\python"))
  ```

  通常使用4、5比较多，还可以自定义匹配规则，默认是会寻找目录下test*.py文件，即所有以test开头命名的py文件，自定义如下:

  ```python
  loader = unittest.TestLoader()
  suite.addTest(loader.discover(start_dir=r"d:\learn\pythib",pattern="test_case*.py"))
  
  
  ```

  

##### TestRunner执行用例

 test runner顾名思义就是用来执行测试用例的，并且可以生成相应的测试报告。测试报告有两种展示形式，一种是text文本，一种是html格式。

 html格式的就是HTMLTestRunner了，`HTMLTestRunner`是 Python 标准库的 unittest 框架的一个扩展，它可以生成一个直观清晰的 HTML 测试报告。使用的前提就是要下载 HTMLTestRunner.py，下载完后放在python的安装目录下的scripts目录下即可。

 text文本相对于html来说过于简陋，与控制台输出的没有什么区别，也几乎没有人使用，这里不作演示，使用方法是一样的。我们结合前面的测试套件来演示一下如何生成html格式的测试报告：

```python
import unittest
import test_register
from HTMLTestRunner import HTMLTestRunner

# 创建测试套件
suite = unittest.TestSuite()

# 通过模块加载测试用例
loader = unittest.TestLoader()
suite.addTest(loader.loadTestsFromModule(test_register))

# 创建测试运行程序启动器
runner = HTMLTestRunner(stream=open("report.html", "wb"),  # 打开一个报告文件，将句柄传给stream
                        tester="miki",                    # 报告中显示的测试人员
                        description="注册接口测试报告",        # 报告中显示的描述信息
                        title="自动化测试报告")                 # 报告的标题

# 使用启动器去执行测试套件里的用例
runner.run(suite)
```

 **相关参数说明：**

- `stream`：指定输出的方式
- `tester`：报告中要显示的测试人员的名字
- `description`：报告中要显示的面熟信息
- `title`：测试报告的标题
- ```verbosity```：表示测试报告信息的详细程度，一共三个值，默认是2
  - 0 (静默模式)：你只能获得总的测试用例数和总的结果，如：总共100个 失败10 成功90
  - 1 (默认模式)：类似静默模式，只是在每个成功的用例前面有个. 每个失败的用例前面有个F
  - 2 (详细模式)：测试结果会显示每个测试用例的所有相关的信息

 运行完毕，你会发现你的项目目录下已经生成了一个report.html文件，在浏览器中打开，就可以查看测试报告了























- 启动方式
  - python -m unittest xxx.xxx
    - 以命令行的方式，也是我们正常执行用例和调试的时候使用的命令。
  - unittest.main()
    - 是代码中编排执行测试用例的时候常用的方法。
- 











### 8 Bug记录

- raise MaxRetryError(_pool, url, error or ResponseError(cause)) urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='127.0.0.1', port=9000): Max retries exceeded with url: /atest?location= (Caused by SSLError(SSLError(1, '[SSL: WRONG_VERSION_NUMBER]

  

  将secure设置为False，结果成功了。

  minioClient = Minio('172.16.154.101:9000',
                      access_key='AKIAIOSFODNN7EXAMPLE',
                      secret_key='wJalrXUtnFEMIK7MDENGbPxRfiCYEXAMPLEKEY',
                      secure=False)

  指定为True表示使用HTTPS协议，按套路不指定就应该默认使用http协议，这儿必须手动指定为False才可以。

- AttributeError: partially initialized module 'zipfile' has no attribute 'ZipFile' (most likely due to a circular import)

  文件名不能设置为zipfile.py
  
- minio上传zip压缩包没问题，但上传文件夹，一直报错：

  PermissionError: [Errno 13] Permission denied: './download/unzip_data_copy/'

- path_copy必须设置为'download/unzip_data_copy/' ，一定要加'/'，或者在

  ```python
  for subfolder in subfolderList:
      rename_file(path+'/'+subfolder) #添加'/'
      print('子文件夹'+subfolder+'重命名完毕!')   
  
  
  ```

  

### 9 代码优化

#### minio配置类

```python
class MinioConfig{
    
    
    def init():
    	client = 
    
    
    
    
    
}
```

